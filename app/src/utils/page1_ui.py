import pandas as pd
import streamlit as st
import matplotlib.pyplot as plt
from stop_words import get_stop_words
from nltk.util import bigrams
from collections import Counter
from wordcloud import WordCloud

from src.utils.etl import get_digest_date


def create_expander_multiselect(label, df, col):
    """Create in Streamlit a multiselect within an expander"""
    values = list(df[col].unique())
    with st.expander(f"**{label}**"):
        return st.multiselect("e", values, default=values, label_visibility="collapsed", key=label)


@st.cache_resource(show_spinner=False)
def plot_wordcloud(df, gram):
    fig, ax = plt.subplots()
    stopwords = set(get_stop_words('french'))

    if gram == 'Uni-grams':
        text = " ".join(
            str(review) for review in df['Mots cl√©s'] if review and not pd.isnull(review)
            )
        wordcloud = WordCloud(
            stopwords=stopwords, background_color="white", width=800, height=400, mode="RGBA"
            ).generate(text)
    elif gram == 'Bi-grams':
        data = df['Mots cl√©s'].astype(str).values.tolist()
        filtered_data = [item.split(',') for item in data if item != 'nan']
        bigram_list = [bigram for sublist in filtered_data for bigram in bigrams(sublist)]
        bigram_strings = ['/'.join(bigram) for bigram in bigram_list]
        bigram_frequency = Counter(bigram_strings)
        wordcloud = WordCloud(
            width=800, height=400, background_color='white'
            ).generate_from_frequencies(bigram_frequency)
    else:  # this never happens
        raise ValueError("Invalid mode. Choose 'Uni-grams', 'Bi-grams'.")

    ax.imshow(wordcloud, interpolation='bilinear')
    ax.axis("off")
    return st.pyplot(fig)


def plot_category_distributions(df, column_names):
    """
    Plots the distribution of categories for the given list of columns
    in the DataFrame as a single figure with multiple subplots.

    Parameters:
    - df: pandas.DataFrame containing the data
    - column_names: list of strings, names of the columns to plot
    """
    num_columns = len(column_names)

    fig, axs = plt.subplots(1, num_columns, figsize=(5 * num_columns, 5))

    if num_columns == 1:
        axs = [axs]

    for ax, column in zip(axs, column_names):
        value_counts = df[column].value_counts()

        ax.bar(value_counts.index, value_counts.values, color='skyblue', edgecolor='black')
        ax.set_title(f'{column}')
        ax.set_ylabel('Frequency')
        plt.sca(ax)
        plt.xticks(rotation=45)

    plt.tight_layout()
    st.pyplot(fig)


def show_recommendations(recommendations):
    """Displays recommendations in an interactive format using Streamlit."""
    st.markdown(
        "##### Recommendations:",
        help="Click on the expander for more info about the event"
        )
    for _, row in recommendations.iterrows():
        with st.expander(rf":pencil2:  **{row['Titre']}** - {row['Chapeau']}"):
            st.markdown(f"**Description:** {row['Description']}", unsafe_allow_html=True)
            if (row['Date de d√©but'] != "") and (row['Date de fin'] != ""):
                st.write(f"""
                **Date:**
                From {get_digest_date(row['Date de d√©but'])}
                to {get_digest_date(row['Date de fin'])}
                """)
            st.write(f"**Plus d'informations en cliquant [ici]({row['URL']}).**")


def download_results(results):
    """
    Creates a download button for users to download recommendation results.

    Parameters:
    - results (BytesIO or similar): The data to be downloaded, typically generated by
      the 'to_excel' function.

    Returns:
    - Streamlit Download Button: A download button rendered by Streamlit, allowing the
      user to download the provided data as an XLSX file.
    """
    return st.sidebar.download_button(
        label="üì• Download recommendations as XLSX",
        data=results,
        file_name='results.csv'
    )
